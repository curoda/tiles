<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sliding Puzzle Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
    }

    body {
      background-color: #f2f2f2;
    }

    .screen-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      width: 100%;
    }

    .hidden {
      display: none !important;
    }

    /* Start Screen */
    #start-screen h1 {
      font-size: 2em;
      margin-bottom: 1em;
      color: #c62828;
    }

    #start-screen input {
      font-size: 1em;
      padding: 0.5em;
      width: 200px;
      margin-bottom: 1em;
      text-align: center;
    }

    #start-screen button {
      font-size: 1.2em;
      padding: 0.7em 1.2em;
      background-color: #c62828;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #start-screen button:hover {
      background-color: #b71c1c;
    }

    /* Game Screen */
    #game-screen {
      padding: 1em;
      background: #e0f7fa;
    }

    header h2 {
      font-size: 1.5em;
      margin-bottom: 0.5em;
      color: #c62828;
    }

    #timer {
      font-size: 1.2em;
      color: #004d40;
    }

    .puzzle-container {
      width: 90vw;
      max-width: 400px;
      height: 90vw;
      max-height: 400px;
      position: relative;
      margin: 0 auto;
      border: 2px solid #ccc;
      border-radius: 10px;
      overflow: hidden;
      background: #fff;
    }

    .tile {
      position: absolute;
      transition: transform 0.3s ease;
      background-size: 400% 400%;
      background-repeat: no-repeat;
      cursor: pointer;
      user-select: none;
      -webkit-user-select: none;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
    }

    .empty-tile {
      background: none;
      cursor: default;
      box-shadow: inset 1px 1px 3px rgba(0,0,0,0.1);
    }

    /* Win Overlay */
    .overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      z-index: 999;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .overlay-content {
      background: #fff;
      color: #000;
      padding: 2em;
      text-align: center;
      border-radius: 10px;
      width: 80%;
      max-width: 400px;
    }

    .overlay-content h2 {
      font-size: 1.8em;
      margin-bottom: 0.5em;
    }

    .overlay-content p {
      margin-bottom: 1em;
      font-size: 1.2em;
    }

    .overlay-content button {
      font-size: 1em;
      padding: 0.7em 1.2em;
      background-color: #006064;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    .overlay-content button:hover {
      background-color: #004d40;
    }
  </style>
</head>
<body>
  <!-- Start Screen -->
  <div id="start-screen" class="screen-container">
    <h1>Welcome to the Puzzle Game!</h1>
    <input type="text" id="username" placeholder="Enter your name" />
    <button id="start-btn">Start Game</button>
  </div>

  <!-- Game Screen -->
  <div id="game-screen" class="screen-container hidden">
    <header>
      <h2>Solve the puzzle, claim your prize!</h2>
      <div id="timer">00:00</div>
    </header>
    <div id="puzzle-container" class="puzzle-container"></div>
  </div>

  <!-- Win Overlay -->
  <div id="win-overlay" class="overlay hidden">
    <div class="overlay-content">
      <h2 id="overlay-message">Congratulations!</h2>
      <p id="overlay-time"></p>
      <button id="play-again-btn">Play Again</button>
    </div>
  </div>

  <script>
    let puzzle = [];
    let emptyIndex = 15;
    let selectedImage = '';
    let timerInterval;
    let startTime;

    const images = [
      'sumo.webp',
      'unicorn.webp',
      'beach.webp',
      'reindeer.webp',
      'platy.webp',
      'grinch.webp',
      'karate.webp',
      'otter.webp'
    ];

    const puzzleContainer = document.getElementById('puzzle-container');
    const timerDisplay = document.getElementById('timer');
    const startScreen = document.getElementById('start-screen');
    const gameScreen = document.getElementById('game-screen');
    const winOverlay = document.getElementById('win-overlay');
    const overlayMessage = document.getElementById('overlay-message');
    const overlayTime = document.getElementById('overlay-time');

    document.getElementById('start-btn').addEventListener('click', () => {
      selectedImage = images[Math.floor(Math.random() * images.length)];
      initializePuzzle();
      startTime = Date.now();
      timerInterval = setInterval(updateTimer, 1000);
      startScreen.classList.add('hidden');
      gameScreen.classList.remove('hidden');
      renderPuzzle();
    });

    document.getElementById('play-again-btn').addEventListener('click', () => {
      winOverlay.classList.add('hidden');
      startScreen.classList.remove('hidden');
      clearInterval(timerInterval);
    });

    function initializePuzzle() {
      // Create the initial puzzle array with numbers 0-14 and 'empty'
      puzzle = [];
      for (let i = 0; i < 16; i++) {
        puzzle[i] = i < 15 ? i : 'empty';
      }
      emptyIndex = 15; // Start with empty tile at bottom right
      console.log('Initial puzzle:', [...puzzle]);
      console.log('Initial empty index:', emptyIndex);
      shufflePuzzle();
    }

    function renderPuzzle() {
      puzzleContainer.innerHTML = '';
      const containerWidth = puzzleContainer.offsetWidth;
      const containerHeight = puzzleContainer.offsetHeight;
      const tileWidth = containerWidth / 4;
      const tileHeight = containerHeight / 4;

      puzzle.forEach((tile, index) => {
        const tileDiv = document.createElement('div');
        tileDiv.classList.add('tile');
        
        const row = Math.floor(index / 4);
        const col = index % 4;
        tileDiv.style.width = `${tileWidth}px`;
        tileDiv.style.height = `${tileHeight}px`;
        tileDiv.style.transform = `translate(${col * tileWidth}px, ${row * tileHeight}px)`;

        if (tile === 'empty') {
          tileDiv.classList.add('empty-tile');
          tileDiv.style.backgroundColor = '#eee';
          tileDiv.style.border = '1px solid #ddd';
        } else {
          const tileRow = Math.floor(tile / 4);
          const tileCol = tile % 4;
          // Calculate background position to show correct part of the image
          const tileRow = Math.floor(tile / 4);
          const tileCol = tile % 4;
          tileDiv.style.backgroundImage = `url('/api/placeholder/400/400')`;
          tileDiv.style.backgroundPosition = `${-tileCol * 100 / 3}% ${-tileRow * 100 / 3}%`;
          tileDiv.style.backgroundSize = '400% 400%';
          tileDiv.style.border = '1px solid #999';
          tileDiv.style.fontSize = '24px';
          tileDiv.style.display = 'flex';
          tileDiv.style.alignItems = 'center';
          tileDiv.style.justifyContent = 'center';
          tileDiv.style.color = '#666';
          tileDiv.textContent = tile + 1;
        }

        tileDiv.style.width = `${tileWidth}px`;
        tileDiv.style.height = `${tileHeight}px`;

        const row = Math.floor(index / 4);
        const col = index % 4;
        tileDiv.style.transform = `translate(${col * tileWidth}px, ${row * tileHeight}px)`;

        tileDiv.addEventListener('click', () => moveTile(index));
        puzzleContainer.appendChild(tileDiv);
      });
    }

    function shufflePuzzle() {
      let moves = 0;
      while (moves < 200) {
        const possibleMoves = getValidMoves();
        if (possibleMoves.length > 0) {
          const randomMove = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
          swapTiles(randomMove, emptyIndex);
          moves++;
        }
      }
    }

    function getValidMoves() {
      const validMoves = [];
      const row = Math.floor(emptyIndex / 4);
      const col = emptyIndex % 4;

      if (row > 0) validMoves.push(emptyIndex - 4); // up
      if (row < 3) validMoves.push(emptyIndex + 4); // down
      if (col > 0) validMoves.push(emptyIndex - 1); // left
      if (col < 3) validMoves.push(emptyIndex + 1); // right

      return validMoves;
    }

    function swapTiles(index1, index2) {
      console.log('Swapping tiles:', index1, index2);
      console.log('Before swap:', [...puzzle]);
      [puzzle[index1], puzzle[index2]] = [puzzle[index2], puzzle[index1]];
      if (puzzle[index1] === 'empty') {
        emptyIndex = index1;
      } else if (puzzle[index2] === 'empty') {
        emptyIndex = index2;
      }
      console.log('After swap:', [...puzzle]);
      console.log('Empty index is now:', emptyIndex);
    }

    function moveTile(clickedIndex) {
      console.log('Clicked index:', clickedIndex);
      console.log('Current empty index:', emptyIndex);
      console.log('Current puzzle state:', puzzle);
      
      // Only allow moving tiles adjacent to the empty space
      if (isAdjacent(clickedIndex, emptyIndex)) {
        // Get current tile values
        const clickedTile = puzzle[clickedIndex];
        const emptyTile = puzzle[emptyIndex];
        
        // Update puzzle array
        puzzle[emptyIndex] = clickedTile;
        puzzle[clickedIndex] = emptyTile;
        
        // Update empty index
        emptyIndex = clickedIndex;
        
        console.log('After move:');
        console.log('New empty index:', emptyIndex);
        console.log('New puzzle state:', puzzle);
        
        renderPuzzle();
        
        if (checkWin()) {
          endGame();
        }
      } else {
        console.log('Not adjacent to empty tile');
      }
    }

    function isAdjacent(index1, index2) {
      const row1 = Math.floor(index1 / 4);
      const col1 = index1 % 4;
      const row2 = Math.floor(index2 / 4);
      const col2 = index2 % 4;
      return (
        (row1 === row2 && Math.abs(col1 - col2) === 1) ||
        (col1 === col2 && Math.abs(row1 - row2) === 1)
      );
    }

    function checkWin() {
      return puzzle.slice(0, 15).every((tile, index) => tile === index);
    }

    function endGame() {
      clearInterval(timerInterval);
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const seconds = (elapsed % 60).toString().padStart(2, '0');
      overlayMessage.textContent = "You solved it!";
      overlayTime.textContent = `Time: ${minutes}:${seconds}`;
      winOverlay.classList.remove('hidden');
    }

    function updateTimer() {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const seconds = (elapsed % 60).toString().padStart(2, '0');
      timerDisplay.textContent = `${minutes}:${seconds}`;
    }
  </script>
</body>
</html>
